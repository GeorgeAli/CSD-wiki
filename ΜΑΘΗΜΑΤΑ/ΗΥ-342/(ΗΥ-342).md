# [(HY-342) Παράλληλος Προγραμματσμός](http://www.csd.uoc.gr/~hy342/)

## Ποιες διαφορες μεταξύ **Processes vs Threads**;
Processes | Threads
--- | ---
Processes are heavyweight operations |	Threads are lighter weight operations
Each process has its own memory space	 | Threads use the memory of the process they belong to
Inter-process communication is slow as processes have different memory addresses | Inter-thread communication can be faster than inter-process communication because threads of the same process share memory with the process they belong to
Context switching between processes is more expensive	| Context switching between threads of the same process is less expensive
Processes don’t share memory with other processes	| Threads share memory with other threads of the same process
 
## Τι είναι Map Reduce;
A **MapReduce** program is composed of a **map procedure** (*or method*), which performs **filtering and sorting** (*such as sorting students by first name into queues, one queue for each name*), and a **reduce method**, which performs a **summary operation** (*such as counting the number of students in each queue, yielding name frequencies*). The "MapReduce System" (also called "infrastructure" or "framework") orchestrates the processing by marshalling the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, and providing for redundancy and fault tolerance.

## Τι είναι Mutexes;
**Mutual exclusion** object (*mutex*) is a program object that allows multiple program threads to share the same resource, such as file access, but not simultaneously. It is a two state mechanism, of locks, whomever locks them must unlock them.

## Τι είναι Data Race;
Is the race between threads, who want to access the same data, but only one can at a time.

## Τι είναι Reader-Writer Locks;
**Readers–writer** (RW) or shared-exclusive lock is a synchronization primitive that solves one of the readers–writers problems*. An RW lock allows concurrent access for read-only operations, while write operations require exclusive access. This means that multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data. When a writer is writing the data, all other writers or readers will be blocked until the writer is finished writing. A common use might be to control access to a data structure in memory that cannot be updated atomically and is invalid (and should not be read by another thread) until the update is complete.

## Ποιες και τι είναι Scheduling policies;
* Scheduling policies
> Scheduling is the method by which work specified by some means is assigned to resources that complete the work. The work may be virtual computation elements such as threads, processes or data flows, which are in turn scheduled onto hardware resources such as processors, network links or expansion cards.

* Scheduling disciplines
> Scheduling disciplines are algorithms used for distributing resources among parties which simultaneously and asynchronously request them.
> 1. First come, first served (FIFO)
> 2. Earliest deadline first
> 3. Shortest remaining time first[edit]
> 4. Fixed priority pre-emptive scheduling[edit]
> 5. Round-robin scheduling
> 6. Multilevel queue scheduling
> 7. Work-conserving schedulers
> 8. Scheduling optimization problems
> 9. Manual scheduling

## Τι είναι Priority Inversion;
In computer science, priority inversion is a problematic scenario in scheduling in which a high priority task is indirectly preempted by a lower priority task effectively "inverting" the relative priorities of the two tasks.

## Τι είναι Load Balancing;
Load balancing improves the distribution of workloads across multiple computing resources, such as computers, a computer cluster, network links, central processing units, or disk drives.

## Τι είναι Memoizing;
Memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

## Τι είναι Consistency;
The data consistency model specifies a contract between programmer and system, wherein the system guarantees that if the programmer follows the rules, memory will be consistent and the results of reading, writing, or updating memory will be predictable.

## Τι είναι Data Race και πως προκαλείται και πως μπορούμε να το αποφύγουμε;
A data race occurs when **two or more threads in a single process access the same memory** location **concurrently**, and. **at least one of the accesses is for writing**, and the threads are not using any exclusive locks to control their accesses to that memory (Memory corruption).

Data races can be avoided by: <br>
> * execute functions seqeuncially
> * mutex
> * atomic

## Τι είναι Resource Contention;
**Resource contention** is a conflict over access to a shared resource such as random access memory, disk storage, cache memory, internal buses or external network devices. A resource experiencing ongoing contention can be described as oversubscribed.

## Τι είναι Load Balancing;
**Load balancing** improves the distribution of workloads across multiple computing resources, such as computers, a computer cluster, network links, central processing units, or disk drives.

## Τι είναι Lock Avoidance όταν χρησιμοποιούμε shared data;
Lock avoidance is a mechanism to access data without locking while still maintaining data integrity. It prohibits access to uncommitted data and serializes access to pages. Lock avoidance improves performance by reducing the overall volume of lock requests. After all, let’s face it, the most efficient lock is the one never taken.

## Ποια η διαφορά μεταξύ Concurrent και Parallel Programming;
* Concurrent Programming
> A concurrent program is **one** defining actions that may be performed "simultaneously", in the sense that more than one processes are running at the same time on the same hardware small amounts of time at a time, giving the perception of parallelism. 

* Parallel Programming
>	A parallel program is **one** defining actions that may be performed **simultaneously**, in the sense that more than one threads are running at the same time on diffrent hardware, in a trully parallel manner. 

## Ποια η διαφορά του deadlock από το livelock;
* A deadlock is a state in which each member of a group is waiting for some other member to take action, such as sending a message or more commonly releasing a lock.
* A livelock is similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing.
> Both dead and live locks are stuck in a state they connot leave, but in a live lock, control flow and states are switched between parties, with no one progressing.

***

## Thread implementation in diffrent languages

programming language | positives | negatives
--- | --- | ---
pthreads | | 
openmp | | 
tbb | | 
java | | 
scala | | 

### Pthreads Example
```
#include <pthread.h>
#include <stdio.h>

/* this function is run by the second thread */
void *inc_x(void *x_void_ptr)
{

    /* increment x to 100 */
    int *x_ptr = (int *)x_void_ptr;
    while(++(*x_ptr) < 100);

    printf("x increment finished\n");

    /* the function must return something - NULL will do */
    return NULL;

}

int main()
{

    int x = 0, y = 0;

    /* show the initial values of x and y */
    printf("x: %d, y: %d\n", x, y);

    /* this variable is our reference to the second thread */
    pthread_t inc_x_thread;

    /* create a second thread which executes inc_x(&x) */
    if(pthread_create(&inc_x_thread, NULL, inc_x, &x)) {

    fprintf(stderr, "Error creating thread\n");
    return 1;

    }
    /* increment y to 100 in the first thread */
    while(++y < 100);

    printf("y increment finished\n");

    /* wait for the second thread to finish */
    if(pthread_join(inc_x_thread, NULL)) {

    fprintf(stderr, "Error joining thread\n");
    return 2;

    }

    /* show the results - x is now 100 thanks to the second thread */
    printf("x: %d, y: %d\n", x, y);

    return 0;

}
```
